// npm install react-native-animatable
// npm install uuid
// npm install react-native-get-random-values

import React, { useState, useRef, useEffect } from "react";
import {
  View,
  Text,
  TextInput,
  TouchableOpacity,
  FlatList,
  Image,
  StyleSheet,
  KeyboardAvoidingView,
  Platform,
} from "react-native";
import {
  findBook,
  hasBook,
  bookIn4,
  checkFine,
  Account,
  Chekouts,
  findBooksByKeyword,
  getUserInfo,
} from "./API/supabaseFunction";
import * as Animatable from "react-native-animatable";
import { useRoute } from "@react-navigation/native";
import { v4 as uuidv4 } from "uuid";
import "react-native-get-random-values";
import AccountMenu from "./AccountMenu";

// {"threadID": "thread_jRKvlP7KMNYsWDZln52irdWk", "userID": 1}
const threadId = "thread_jRKvlP7KMNYsWDZln52irdWk";

const API_KEY =
  "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";
const ASSISTANT_ID = "asst_kHUXL5hpZVISj4ytuhHcCXzJ"; // BoBo
const FINE_TUNING = "ft:gpt-4o-mini-2024-07-18:phamhuuhung::B7LmIhDo";
//const USER_ID = 1;
const initialMessages = [
  { id: "1", type: "assistant", text: "Ch√†o b·∫°n, t√¥i c√≥ th·ªÉ gi√∫p g√¨ cho b·∫°n?" },
];

const ChatScreen2 = () => {
  const [messages, setMessages] = useState([]);
  const [input, setInput] = useState("");
  const [nameOfBook, setNameOfBook] = useState("");
  const [keyword, setKeyword] = useState("");
  const [isThinking, setIsThinking] = useState(false);
  const [accountMenuVisible, setAccountMenuVisible] = useState(false);
  const flatListRef = useRef(null);
  const route = useRoute();
  const { userID, threadID } = route.params;
  const currentUserID = userID;
  const [avatarUri, setAvatarUri] = useState(null);
  const [UserName, setUserName] = useState("");

  // Hi·ªáu ·ª©ng c·∫≠p nh·∫≠t 3 d·∫•u ch·∫•m suy nghƒ©
  useEffect(() => {
    let interval;
    if (isThinking) {
      let dotCount = 0;
      interval = setInterval(() => {
        dotCount = (dotCount + 1) % 4; // 0 -> 1 -> 2 -> 3 -> 0...
        setMessages((prevMessages) =>
          prevMessages.map((m) =>
            m.id === "thinking" ? { ...m, text: ".".repeat(dotCount) } : m
          )
        );
      }, 500);
    }
    return () => {
      if (interval) clearInterval(interval);
    };
  }, [isThinking]);

  // T·ª± ƒë·ªông cu·ªôn xu·ªëng d∆∞·ªõi khi c√≥ tin nh·∫Øn m·ªõi
  useEffect(() => {
    if (flatListRef.current) {
      flatListRef.current.scrollToEnd({ animated: true });
    }
  }, [messages]);

  // L·∫•y avatar
  useEffect(() => {
    async function loadAvatar() {
      const info = await getUserInfo(currentUserID); // currentUserId ƒë∆∞·ª£c l·∫•y t·ª´ LoginScreen
      setAvatarUri(info.Avatar);
    }
    loadAvatar();
  }, [currentUserID]);

  //L·∫•y User name
  useEffect(() => {
    async function loadUserName() {
      const info = await getUserInfo(currentUserID);
      const fullName = (info.FullName || "").trim(); 
      const nameParts = fullName.split(" ");
      const firstName = nameParts[nameParts.length - 1];
      setUserName(firstName);
    }
    loadUserName();
  }, [currentUserID]);

  // useEffect(() => {
  //   console.log("UserName:", UserName);
  // }, [UserName]);
  

  // Sau khi l·∫•y ƒë∆∞·ª£c UserName, c·∫≠p nh·∫≠t tin nh·∫Øn ch√†o ƒë·∫ßu ti√™n
  useEffect(() => {
    if (UserName) {
      setMessages([
        {
          id: "1",
          type: "assistant",
          text: `Ch√†o ${UserName}, t√¥i c√≥ th·ªÉ gi√∫p g√¨ cho b·∫°n?`,
        },
      ]);
    }
  }, [UserName]);

  const sendMessage = async () => {
    if (!threadId) {
      console.error("‚ùå Thread ID not available");
      alert("H·ªá th·ªëng g·∫∑p l·ªói");
      return;
    }

    if (input.trim() === "") return;

    const userMessage = {
      id: Date.now().toString(),
      type: "user",
      text: input,
    };
    // Th√™m tin nh·∫Øn c·ªßa ng∆∞·ªùi d√πng v√† hi·ªáu ·ª©ng suy nghƒ© (ƒë∆∞·ª£c nh·∫≠n d·∫°ng b·∫±ng id "thinking")
    setMessages((prev) => [
      ...prev,
      userMessage,
      { id: "thinking", type: "assistant", text: "" },
    ]);
    setInput("");
    setIsThinking(true);

    var fetchedData = await classifyFunctions(input);

    // Ch·ªânh s·ª≠a d·ªØ li·ªáu cho ƒë·∫πp h∆°n
    const formattedData =
      Array.isArray(fetchedData) && fetchedData.length > 0
        ? JSON.stringify(fetchedData, null, 2)
        : "Kh√¥ng c√≥ d·ªØ li·ªáu";

    const prompt = {
      role: "user",
      content: `ƒê√¢y l√† input c·ªßa ng∆∞·ªùi d√πng : ${input}. \nƒê√¢y l√† d·ªØ li·ªáu t·ª´ database : ${formattedData}. \
H√£y tr·∫£ l·ªùi d·ª±a tr√™n d·ªØ li·ªáu tr√™n. N·∫øu d·ªØ li·ªáu kh√¥ng r·ªóng, h√£y li·ªát k√™ c√°c cu·ªën s√°ch v√† th√¥ng tin chi ti·∫øt, kh√¥ng t·ª± sinh th√™m th√¥ng tin kh√°c. \
N·∫øu kh√¥ng c√≥ d·ªØ li·ªáu t·ª´ database th√¨ b·∫°n h√£y t·ª± x·ª≠ l√Ω c√¢u h·ªèi c·ªßa ng∆∞·ªùi d√πng, sau khi x·ª≠ l√Ω xong r·ªìi th√¨ check l·∫°i n·∫øu input ng∆∞·ªùi d√πng kh√¥ng n·∫±m trong ph·∫°m \
vi th∆∞ vi·ªán th√¨ h√£y ph·∫£n h·ªìi th√™m l√† : "T√¥i l√† chatbot th∆∞ vi·ªán n√™n b·∫°n h√£y h·ªèi nh·ªØng ch·ªß ƒë·ªÅ li√™n quan ƒë·∫øn th∆∞ vi·ªán" ho·∫∑c \
"Vui l√≤ng cung c·∫•p t√™n s√°ch ho·∫∑c y√™u c·∫ßu c·ªßa b·∫°n r√µ r√†ng h∆°n" (ph·∫ßn n√†y h√£y xu·ªëng h√†ng ƒë·ªÉ d·ªÖ ƒë·ªçc).`,
    };

    try {
      console.log("üì§ Sending message:", userMessage);
      const response = await fetch(
        `https://api.openai.com/v1/threads/${threadId}/messages`,
        {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            Authorization: `Bearer ${API_KEY}`,
            "OpenAI-Beta": "assistants=v2",
          },
          body: JSON.stringify(prompt),
        }
      );

      const data = await response.json();
      console.log("‚úÖ Message sent:", data);

      if (data?.id) {
        await runAssistant();
      } else {
        console.error(
          "‚ùå Error sending message:",
          JSON.stringify(data, null, 2)
        );
      }
    } catch (error) {
      console.error("üö® Error sending message:", error.message);
    }
  };

  async function extractIntent(userQuery, bookNAME, keyword) {
    console.log("ü§î G·ªçi h√†m extract");
    const prompt = `H√£y ch·ªâ cho t√¥i bi·∫øt √Ω ƒë·ªãnh (intent) c·ªßa c√¢u h·ªèi sau thu·ªôc trong nh√≥m c√°c intent ch√≠nh n√†o m√† t√¥i ƒë√£ ph√¢n lo·∫°i \
(T√¨m v·ªã tr√≠ s√°ch, C√≥ s√°ch n√†y kh√¥ng?, T√¨m s√°ch theo t√≥m t·∫Øt, Th√¥ng tin s√°ch, Ki·ªÉm tra ph√≠ ph·∫°t, Th√¥ng tin t√†i kho·∫£n, L·ªãch s·ª≠ m∆∞·ª£n s√°ch) \
v√† t√™n s√°ch (n·∫øu c√≥), b·∫°n h√£y ki·ªÉm tra xem t√™n c·ªßa cu·ªën s√°ch ƒë∆∞·ª£c nh·∫≠p t·ª´ ng∆∞·ªùi d√πng c√≥ vi·∫øt ch√≠nh x√°c kh√¥ng, n·∫øu kh√¥ng ch√≠nh x√°c th√¨ h√£y s·ª≠a l·∫°i cho ƒë√∫ng t√™n chu·∫©n.
Tr·∫£ v·ªÅ k·∫øt qu·∫£ d∆∞·ªõi d·∫°ng JSON v·ªõi ƒë·ªãnh d·∫°ng (ch·ªâ tr·∫£ v·ªÅ ƒë√∫ng ƒë·ªãnh d·∫°ng kh√¥ng th√™m b·∫•t c·ª© g√¨ c·∫£):
  {
    "intent": "...",
    "bookName": "...",
    "keyword": "..."
  }
Ch·ªâ tr·∫£ v·ªÅ m·ªôt t·ª´ ho·∫∑c c·ª•m t·ª´ ng·∫Øn g·ªçn (kh√¥ng k√®m gi·∫£i th√≠ch). N·∫øu input c·ªßa ng∆∞·ªùi d√πng kh√¥ng ph√π h·ª£p v·ªõi c√°c intents ƒë√£ ph√¢n lo·∫°i s·∫µn ·ªü tr√™n th√¨ tr·∫£ v·ªÅ chu·ªói l√† "KO".
Cu·ªën s√°ch ƒë√£ ƒë∆∞·ª£c ƒë·ªÅ c·∫≠p: "${bookNAME}", ch·ªâ s·ª≠ d·ª•ng ƒë·∫øn gi√° tr·ªã n√†y khi ng∆∞·ªùi d√πng ƒë·ªÅ c·∫≠p t·ªõi cu·ªën s√°ch tr∆∞·ªõc ƒë√≥ m√† h·ªç kh√¥ng n√≥i t√™n cu·ªën s√°ch.
C√¢u h·ªèi: "${userQuery}"
T·ª´ kh√≥a: "${keyword}".`;

    try {
      const response = await fetch(
        "https://api.openai.com/v1/chat/completions",
        {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            Authorization: `Bearer ${API_KEY}`,
          },
          body: JSON.stringify({
            model: "gpt-4o-mini",
            messages: [
              {
                role: "system",
                content:
                  "B·∫°n l√† tr·ª£ l√Ω ph√¢n t√≠ch √Ω ƒë·ªãnh v√† tr√≠ch xu·∫•t th√¥ng tin s√°ch.",
              },
              { role: "user", content: prompt },
            ],
            max_tokens: 100,
            temperature: 0.2,
          }),
        }
      );

      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }

      const data = await response.json();
      console.log(
        "üí° *Ket qua EXTRACT*: ",
        data.choices[0].message.content.trim()
      );
      const resultText = data.choices[0].message.content.trim();

      let result;
      try {
        result = JSON.parse(resultText);
      } catch (err) {
        console.error(
          "L·ªói khi parse JSON:",
          err,
          "VƒÉn b·∫£n tr·∫£ v·ªÅ:",
          resultText
        );
        result = null;
      }

      return result;
    } catch (error) {
      console.error("L·ªói khi tr√≠ch xu·∫•t intent:", error);
      return null;
    }
  }

  const classifyFunctions = async (userInput) => {
    console.log("‚òÄÔ∏è‚òÄÔ∏è‚òÄÔ∏è G·ªçi h√†m classifyFunctions ‚òÄÔ∏è‚òÄÔ∏è‚òÄÔ∏è");
    let dataFromDatabase;
    const keys = await extractIntent(userInput, nameOfBook, "");

    if (keys === "KO" || keys.intent === "KO") {
      return "Kh√¥ng c√≥ d·ªØ li·ªáu ph√π h·ª£p. Vui l√≤ng ƒë·∫∑t c√¢u h·ªèi r√µ r√†ng h∆°n.";
    }

    let finalBookName = nameOfBook;
    if (keys.bookName && keys.bookName !== "KO") {
      finalBookName = keys.bookName;
      await new Promise((resolve) => {
        setNameOfBook(keys.bookName);
        resolve();
      });
    } else {
      finalBookName = "";
    }

    // C·∫≠p nh·∫≠t keyword m·ªõi: n·∫øu keys.keyword h·ª£p l·ªá th√¨ l∆∞u l·∫°i, ng∆∞·ª£c l·∫°i reset
    if (keys.keyword != "") {
      setKeyword(keys.keyword);
    } else {
      setKeyword("");
    }

    console.log("‚≠ê Fetch Data v·ªõi:", keys.intent, finalBookName, keys.keyword);
    dataFromDatabase = await fetchData(
      keys.intent,
      finalBookName,
      keys.keyword
    );
    return dataFromDatabase;
  };

  async function fetchData(currentIntent, currentBookName, keyword) {
    let resData;
    if (currentIntent || currentBookName || keyword) {
      switch (currentIntent) {
        case "T√¨m v·ªã tr√≠ s√°ch": {
          const result = await findBook(currentBookName);
          resData = result;
          console.log(`üìò!@#SAU KHI FETCH SUPABASE: ${result}`);
          break;
        }
        case "T√¨m s√°ch theo t√≥m t·∫Øt": {
          resData = await findBooksByKeyword(keyword);
          console.log("üìò!@#SAU KHI FETCH SUPABASE:", resData);
          break;
        }
        case "C√≥ s√°ch n√†y kh√¥ng?": {
          const result = await hasBook(currentBookName);
          resData = result;
          console.log("!@#SAU KHI FETCH SUPABASE", result);
          break;
        }
        case "Th√¥ng tin s√°ch": {
          const result = await bookIn4(currentBookName);
          resData = result;
          console.log("!@#SAU KHI FETCH SUPABASE", result);
          break;
        }
        case "Ki·ªÉm tra ph√≠ ph·∫°t": {
          const result = await checkFine(currentUserID);
          resData = result;
          console.log("!@#SAU KHI FETCH SUPABASE", result);
          break;
        }
        case "Th√¥ng tin t√†i kho·∫£n": {
          const result = await Account(currentUserID);
          resData = result;
          console.log("!@#SAU KHI FETCH SUPABASE", result);
          break;
        }
        case "L·ªãch s·ª≠ m∆∞·ª£n s√°ch": {
          const result = await Chekouts(currentUserID);
          resData = result;
          console.log("!@#SAU KHI FETCH SUPABASE", result);
          break;
        }
        case "KO": {
          resData = `Kh√¥ng c√≥ d·ªØ li·ªáu`;
          console.log("!@#FETCH SUPABASE TR∆Ø·ªúNG H·ª¢P KO");
          break;
        }
        default:
          resData = `Kh√¥ng c√≥ d·ªØ li·ªáu`;
          console.log("!@#FETCH SUPABASE TR∆Ø·ªúNG H·ª¢P DEFAULT");
      }
      return resData;
    }
  }

  const runAssistant = async () => {
    if (!threadId) {
      console.error("‚ùå Thread ID not available");
      return;
    }

    console.log("üîÑ Starting assistant run...");
    try {
      const response = await fetch(
        `https://api.openai.com/v1/threads/${threadId}/runs`,
        {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            Authorization: `Bearer ${API_KEY}`,
            "OpenAI-Beta": "assistants=v2",
          },
          body: JSON.stringify({
            assistant_id: ASSISTANT_ID,
            model: FINE_TUNING,
          }), // üëà G·ª≠i ID c·ªßa tr·ª£ l√Ω
        }
      );

      const data = await response.json();
      console.log("‚úÖ Assistant run started:", data);

      if (data?.id) {
        await checkRunStatus(data.id); // üëà Ki·ªÉm tra xem ph·∫£n h·ªìi ƒë√£ ho√†n th√†nh ch∆∞a
      } else {
        console.error(
          "‚ùå Error starting assistant run:",
          JSON.stringify(data, null, 2)
        );
      }
    } catch (error) {
      console.error("üö® Error starting assistant run:", error.message);
    }
  };

  const checkRunStatus = async (runId) => {
    console.log("üîç Checking run status...");

    try {
      let status = "in_progress";

      while (status === "queued" || status === "in_progress") {
        const response = await fetch(
          `https://api.openai.com/v1/threads/${threadId}/runs/${runId}`,
          {
            method: "GET",
            headers: {
              Authorization: `Bearer ${API_KEY}`,
              "OpenAI-Beta": "assistants=v2",
            },
          }
        );

        const data = await response.json();
        status = data.status;
        console.log(`‚ÑπÔ∏è Run status: ${status}`);

        if (status === "completed") {
          fetchAssistantReply();
          break;
        } else if (status === "failed") {
          console.error(
            "‚ùå Assistant run failed:",
            JSON.stringify(data, null, 2)
          );
          break;
        }

        await new Promise((resolve) => setTimeout(resolve, 2000)); // ƒê·ª£i 2s tr∆∞·ªõc khi ki·ªÉm tra ti·∫øp
      }
    } catch (error) {
      console.error("üö® Error checking run status:", error.message);
    }
  };

  const fetchAssistantReply = async () => {
    console.log("üì® Fetching assistant reply...");

    try {
      const response = await fetch(
        `https://api.openai.com/v1/threads/${threadId}/messages`,
        {
          method: "GET",
          headers: {
            Authorization: `Bearer ${API_KEY}`,
            "OpenAI-Beta": "assistants=v2",
          },
        }
      );

      const reply = await response.json();

      // D·ª´ng hi·ªáu ·ª©ng suy nghƒ© v√† xo√° tin nh·∫Øn "thinking"
      setIsThinking(false);
      setMessages((prev) => prev.filter((m) => m.id !== "thinking"));

      if (reply?.data) {
        const assistantMessages = reply.data
          .filter((msg) => msg.role === "assistant")
          .map((msg) => ({
            id: uuidv4(),
            type: "assistant",
            text: msg.content[0].text.value,
          })); // üëà L·∫•y n·ªôi dung ƒë√∫ng ƒë·ªãnh d·∫°ng

        let chatbot = assistantMessages[0];
        console.log("ü§ñ Assistant replied:", chatbot);
        if (chatbot) {
          setMessages((prev) => [...prev, chatbot]);
        }
      } else {
        console.error(
          "‚ùå Error fetching messages:",
          JSON.stringify(reply, null, 2)
        );
      }
    } catch (error) {
      console.error("üö® Error fetching assistant reply:", error.message);
    }
  };

  // Hi·ªÉn th·ªã t·ª´ng tin nh·∫Øn v·ªõi animation
  const renderItem = ({ item, index }) => {
    const isUser = item.type === "user";
    return (
      <Animatable.View
        animation="fadeInUp"
        duration={600}
        delay={index * 100}
        style={[
          styles.messageContainer,
          isUser ? styles.userMessage : styles.botMessage,
        ]}
      >
        {!isUser && (
          <Image
            source={{
              uri: "https://img.icons8.com/emoji/48/000000/robot-emoji.png",
            }}
            style={styles.avatar}
          />
        )}
        <View style={[styles.messageBubble, isUser && styles.userBubble]}>
          <Text
            style={
              item.id === "thinking" ? styles.thinkingText : styles.messageText
            }
          >
            {item.text}
          </Text>
        </View>
        {isUser && <Image source={{ uri: avatarUri }} style={styles.avatar} />}
      </Animatable.View>
    );
  };

  return (
    <KeyboardAvoidingView
      style={[styles.container]}
      behavior={Platform.select({ ios: "padding", android: undefined })}
      keyboardVerticalOffset={Platform.select({ ios: 0, android: 0 })}
    >
      {/* Header */}
      <View style={styles.header}>
        <Text style={styles.headerTitle}>Library Chatbot</Text>
        <TouchableOpacity
          onPress={() => setAccountMenuVisible(true)}
          style={styles.accountIcon}
        >
          <Image
            source={{ uri: avatarUri }} // Avatar c·ªßa user
            style={styles.avatar}
          />
        </TouchableOpacity>
      </View>
      <FlatList
        ref={flatListRef}
        data={messages}
        renderItem={renderItem}
        keyExtractor={(item) => item.id}
        contentContainerStyle={styles.messagesList}
      />
      <View style={styles.inputContainer}>
        <TextInput
          style={styles.input}
          placeholder="Nh·∫≠p tin nh·∫Øn..."
          value={input}
          onChangeText={setInput}
          placeholderTextColor="#666"
        />
        <TouchableOpacity style={styles.sendButton} onPress={sendMessage}>
          <Text style={styles.sendButtonText}>G·ª≠i</Text>
        </TouchableOpacity>
      </View>
      <AccountMenu
        visible={accountMenuVisible}
        onClose={() => setAccountMenuVisible(false)}
        userID = {userID}
      />
    </KeyboardAvoidingView>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: "#DBDBDB",
    //backgroundColor: "#212121",
  },
  header: {
    backgroundColor: "#A08963",
    paddingVertical: 15,
    alignItems: "center",
    justifyContent: "center",
    flexDirection: "row",
    position: "relative",
  },
  headerTitle: {
    color: "#fff",
    fontSize: 20,
    fontWeight: "bold",
  },
  messagesList: {
    flexGrow: 1,
    justifyContent: "flex-start",
    paddingHorizontal: 10,
    paddingBottom: 100,
    top: 15,
  },
  messageContainer: {
    flexDirection: "row",
    alignItems: "flex-end",
    marginBottom: 10,
  },
  userMessage: {
    justifyContent: "flex-end",
  },
  botMessage: {
    justifyContent: "flex-start",
  },
  messageBubble: {
    maxWidth: "70%",
    padding: 10,
    borderRadius: 20,
    backgroundColor: "#C9B194",
    shadowColor: "#000",
    shadowOffset: { width: 0, height: 1 },
    shadowOpacity: 0.3,
    shadowRadius: 2,
    elevation: 2,
  },
  userBubble: {
    backgroundColor: "#C9B194",
    //backgroundColor: "#616161",
  },
  messageText: {
    fontSize: 16,
    color: "#1D1616",
    //color: "#fff",
  },
  avatar: {
    width: 36,
    height: 36,
    borderRadius: 18,
    marginHorizontal: 5,
  },
  inputContainer: {
    bottom: 5,
    left: 0,
    right: 0,
    flexDirection: "row",
    paddingHorizontal: 10,
    paddingVertical: 10,
    backgroundColor: "#DBDBDB",
    //backgroundColor: "#333",
    alignItems: "center",
    borderTopWidth: 1,
    borderTopColor: "#ddd",
  },
  input: {
    flex: 1,
    backgroundColor: "#C9B194",
    //backgroundColor: "#424242",
    borderRadius: 20,
    paddingHorizontal: 15,
    paddingVertical: 10,
    fontSize: 16,
    //color: "#333",
    color: "#1D1616",
  },
  sendButton: {
    marginLeft: 10,
    backgroundColor: "#A08963",
    paddingVertical: 10,
    paddingHorizontal: 15,
    borderRadius: 20,
  },
  sendButtonText: {
    color: "#1D1616",
    fontWeight: "bold",
  },
  thinkingText: {
    fontSize: 30,
    color: "#fff",
    fontWeight: "bold",
  },
  accountIcon: {
    position: "absolute",
    right: 10,
    top: "80%",
    transform: [{ translateY: -12 }],
  },
});

export default ChatScreen2;
